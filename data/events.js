/* Dovecot events.
 *
 * Each event is listed with key as event name and value as object. */

export const events = {

	/* fts-flatcurve plugin. */

	fts_flatcurve_expunge: {
		// Root category
		root: 'fts-flatcurve',

		// Change information
		added: {
			fts_flatcurve: false,
		},
		// changed: {
		//     <tag>: `Description of change (or 'false')`,
		// },
		// deprecated: {
		//     <tag>: `Description of change (or 'false')`,
		// },
		// removed: {
		//     <tag>: `Description of change (or 'false')`,
		// },

		// Tag name(s). String or array.
		// tags: 'foo', // or [ 'foo1', 'foo2', ... ]

		// Event(s) this field inherits fields from.
		// Can be a single event or an array of events.
		inherit: '',

		// List of fields emitted. Keys are field names, values are
		// descriptions (string) or an object with multiple keys (see below for
		// example). Values are processed w/Markdown.
		fields: {
			mailbox: `The mailbox name`,
			uid: `The UID that was expunged from FTS index`,

			// Optional object format for entry
			// example: {
				// added: {
				//     <tag>: `Description of change (or 'false')`,
				// },
				// changed: {
				//     <tag>: `Description of change (or 'false')`,
				// },
				// deprecated: {
				//     <tag>: `Description of change (or 'false')`,
				// },
				// removed: {
				//     <tag>: `Description of change (or 'false')`,
				// },
				// Field Description. Rendered w/Markdown
				// text: ``,
			// }
		},

		// Summary of event. Rendered w/Markdown.
		text: `Emitted when a message is expunged from a mailbox.`
	},

	fts_flatcurve_index: {
		added: {
			fts_flatcurve: false,
		},
		root: 'fts-flatcurve',
		fields: {
			mailbox: `The mailbox name`,
			uid: `The UID that was added to the FTS index`
		},
		text: `Emitted when a message is indexed.`
	},

	fts_flatcurve_last_uid: {
		added: {
			fts_flatcurve: false,
		},
		root: 'fts-flatcurve',
		fields: {
			mailbox: `The mailbox name`,
			uid: `The last UID contained in the FTS index`
		},
		text: `Emitted when the system queries for the last UID indexed.`
	},

	fts_flatcurve_optimize: {
		added: {
			fts_flatcurve: false,
		},
		root: 'fts-flatcurve',
		fields: {
			mailbox: `The mailbox name`
		},
		text: `Emitted when a mailbox is optimized.`
	},

	fts_flatcurve_query: {
		added: {
			fts_flatcurve: false,
		},
		root: 'fts-flatcurve',
		fields: {
			count: `The number of messages matched`,
			mailbox: `The mailbox name`,
			maybe: `Are the results uncertain? [yes | no]`,
			query: `The query text sent to Xapian`,
			uids: `The list of UIDs returned by the query`
		},
		text: `Emitted when a query is completed.`
	},

	fts_flatcurve_rescan: {
		added: {
			fts_flatcurve: false,
		},
		root: 'fts-flatcurve',
		fields: {
			expunged: `The list of UIDs that were expunged during rescan`,
			mailbox: `The mailbox name`,
			status: `Status of the rescan [expunge_msgs | missing_msgs | ok]`,
			uids: `The list of UIDs that triggered a non-ok status response`
		},
		text: `Emitted when a rescan is completed.`
	},

	fts_flatcurve_rotate: {
		added: {
			fts_flatcurve: false,
		},
		root: 'fts-flatcurve',
		fields: {
			mailbox: `The mailbox name`
		},
		text: `Emitted when a mailbox has its underlying Xapian DB rotated.`
	},

	/* authentication client
	 *
	 * These events are generated by authentication clients (lib-auth). */

	auth_client_passdb_lookup_started: {
		root: 'auth-client',
		inherit: 'auth_client_lookup',
		text: `Authentication client starts a passdb lookup.`
	},

	auth_client_passdb_lookup_finished: {
		root: 'auth-client',
		inherit: 'auth_client_lookup',
		text: `Authentication client finishes a passdb lookup.`
	},


	auth_client_request_started: {
		root: 'auth-client',
		inherit: 'auth_client_request',
		text: `Authentication client starts authentication request.`
	},

	auth_client_request_challenged: {
		root: 'auth-client',
		inherit: 'auth_client_request',
		text: `
Authentication client receives a request from server to continue SASL
authentication.`
	},

	auth_client_request_continued: {
		root: 'auth-client',
		inherit: 'auth_client_request',
		text: `
Authentication client continues SASL authentication by sending a response
to server request.`
	},

	auth_client_request_finished: {
		root: 'auth-client',
		inherit: 'auth_client_request',
		text: `
Authentication client receives response from server that authentication is
finished, either success or failure.`
	},

	auth_client_userdb_list_started: {
		root: 'auth-client',
		inherit: 'auth_client_common',
		fields: {
			user_mask: `User mask to list.`
		},
		text: `Authentication client starts userdb iteration.`
	},

	auth_client_userdb_list_finished: {
		root: 'auth-client',
		inherit: 'auth_client_common',
		fields: {
			user_mask: `User mask to list.`,
			error: `Error string, if error occurred.`
		},
		text: `Authentication client finishes userdb iteration.`
	},

	auth_client_userdb_lookup_started: {
		root: 'auth-client',
		inherit: 'auth_client_lookup',
		text: `Authentication client starts a userdb lookup.`
	},

	auth_client_userdb_lookup_finished: {
		root: 'auth-client',
		inherit: 'auth_client_lookup',
		text: `Authentication client finishes a userdb lookup.`
	},

	auth_request_finished: {
		root: 'auth',
		inherit: 'auth_server_common',
		fields: {
			error: `Set when error happens.`,
			success: `\`yes\`, when authentication succeeded.`,
			policy_penalty: `Time of penalty added by policy server.`,
			policy_result: `\`ok\`, \`delayed\`, or \`refused\`.`
		},
		text: `
Authentication request finished.

Most useful for tracking status of authentication/login attempts.`
	},

	auth_passdb_request_started: {
		root: 'auth',
		inherit: [ 'auth_server_common', 'auth_server_passdb' ],
		text: `
Processing has begun for a passdb block.

Most useful for debugging authentication flow.`
	},

	auth_passdb_request_finished: {
		root: 'auth',
		inherit: [ 'auth_server_common', 'auth_server_passdb' ],
		fields: {
			result: `
* \`ok\`
* \`password_mismatch\`
* \`user_unknown\`
* \`pass_expired\`
* \`user_disabled\`
* \`scheme_not_available\`
* \`internal_failure\`
* \`next\``,
			cache: `
* \`miss\`: Was not cached
* \`hit\`: Found from cache`,
		},
		text: `
Processing has ended for a passdb block.

Most useful for debugging authentication flow.`
	},

	auth_userdb_request_started: {
		root: 'auth',
		inherit: [ 'auth_server_common', 'auth_server_userdb' ],
		text: `
Processing has begun for a userdb block.

Most useful for debugging authentication flow.`
	},

	auth_userdb_request_finished: {
		root: 'auth',
		inherit: [ 'auth_server_common', 'auth_server_userdb' ],
		fields: {
			result: `
* \`ok\`
* \`user_unknown\`
* \`internal_failure\``,
			cache: `
* \`miss\`: Was not cached
* \`hit\`: Found from cache`,
		},
		text: `
Processing has ended for a userdb block.

Most useful for debugging authentication flow.`
	},

	auth_policy_request_finished: {
		root: 'auth',
		inherit: 'auth_server_common',
		fields: {
			mode: `Either \`allow\` or \`report\`.`,
			policy_result: `Value returned from policy server (number).`,
		},
		text: `
Processing has ended for an auth policy request.

Most useful for debugging authentication flow.`
	},

	/* Authentication Master Client
	 *
	 * These events are generated by master authentication clients
	 * (lib-master). This happens when e.g. IMAP finishes the login by doing
	 * a userdb lookup. */

	auth_master_client_login_started: {
		inherit: 'auth_master_common',
		text: `Authentication master login request started.`
	},

	auth_master_client_login_finished: {
		inherit: 'auth_master_common',
		fields: {
			user: `Username of the user.`,
			error: `Error message if the request failed.`,
		},
		text: `Authentication master login request finished.`
	},


	/* Connection
	 *
	 * These events apply only for connections using the "connection API".
	 * Note: Not all connections currently use this API, so these events work
	 * for some types of connections, but not for others. */

	client_connection_connected: {
		inherit: 'client_connection_common',
		text: `Server accepted an incoming client connection.`
	},

	client_connection_disconnected: {
		inherit: 'client_connection_common',
		fields: {
			net_in_bytes: {
				changed: {
					events_net_in_bytes_changed: `This was previously \`in_bytes\`.`
				},
				text: `Amount of data read, in bytes.`
			},
			net_out_bytes: {
				changed: {
					events_net_out_bytes_changed: `This was previously \`out_bytes\`.`
				},
				text: `Amount of data written, in bytes.`
			},
			reason: `Disconnection reason.`
		},
		text: `Client connection is terminated.`
	},

	server_connection_connected: {
		inherit: 'server_connection_common',
		text: `Outgoing server connection was either successfully established or failed.

::: tip Note
Currently it is not possible to know which one happened.
:::`
	},

	server_connection_disconnected: {
		inherit: 'server_connection_common',
		fields: {
			reason: `Disconnection reason.`
		},
		text: `Server connection is terminated.`
	},

	/* FS */

	// TODO: Better inheritance documentation
	fs: {
		root: 'fs',
		text: `May be inherited from various different parents (e.g. "Mail User" event) or even from no parent.`
	},

	// TODO: Better inheritance documentation
	fs_file: {
		root: 'fs',
		text: `Inherits from fs or any other specified event (e.g. mail).`
	},

	/* Mail User */

	mail_user_session_finished: {
		inherit: 'mail_user',
		fields: {
			utime: `User CPU time used in microseconds.`,
			stime: `System CPU time used in microseconds.`,
			minor_faults: `Page reclaims (soft page faults).`,
			major_faults: `Page faults (hard page faults).`,
			vol_cs: `Voluntary context switches.`,
			invol_cs: `Involuntary context switches.`,
			rss: `Resident set size in bytes. (Skipped in non-Linux environments.)`,
			vsz: `Virtual memory size in bytes. (Skipped in non-Linux environments.)`,
			rchar: `I/O counter: chars (bytes) read from storage. (Skipped in non-Linux environments.)`,
			wchar: `I/O counter: chars (bytes) written to storage. (Skipped in non-Linux environments.)`,
			syscr: `Number of read syscalls. (Skipped in non-Linux environments.)`,
			syscw: `Number of write syscalls. (Skipped in non-Linux environments.)`,
			net_in_bytes: {
				added: {
					events_net_in_bytes_changed: `This was previously \`in_bytes\`.`
				},
				text: `Bytes received during this session (for applicable processes.)`
			},
			net_out_bytes: {
				added: {
					events_net_out_bytes_changed: `This was previously \`out_bytes\`.`
				},
				text: `Bytes sent during this session (for applicable processes.)`
			},
		},
	},

	/* Mailbox */

	mail_expunged: {
		inherit: 'mailbox',
		fields: {
			uid: `UID of the expunged mail.`,
		},
		text: `
A mail was expunged from the mailbox.

::: tip Note
This event inherits from mailbox, not mail.
:::`
	},


	/* Mail */

	mail_metadata_accessed: {
		added: {
			events_mail_metadata_accessed_added: false
		},
		inherit: [ 'mail', 'mailbox' ],
		text: `
A mail was opened for reading its metadata.

::: tip Note
This event is not sent when mails' body is accessed.
:::`
	},

	mail_opened: {
		inherit: [ 'mail', 'mailbox' ],
		fields: {
			reason: `Reason why the mail was opened. (optional)`,
		},
		text: `
A mail was opened, e.g., for reading its body.

::: tip Note
This event is not sent when mails' metadata is accessed, even if it causes
opening the mail file.
:::`
	},

	mail_expunge_requested: {
		inherit: [ 'mail', 'mailbox' ],
		text: `
A mail is set to be expunged.

::: tip Note
Expunges can be rolled back later on, this event is emitted when an expunge
is requested.
:::`
	},

	/* Mail Index
	 *
	 * Index file handling for "dovecot.index*", "dovecot.map.index*",
	 * "dovecot.list.index*" and similar indexes.
	 *
	 * TODO: mail index "Inherits from event_mailbox, event_storage or
	 * event_mail_user depending on what the index is used for." */

	mail_index_recreated: {
		root: 'mail-index',
		fields: {
			filepath: `Path to the index file being recreated.`,
			reason: `Human-readable reason why the mail index was recreated.`,
		},
		text: `A mail index file was recreated.`
	},

	indexer_worker_indexing_finished: {
		root: 'mail-index',
		inherit: 'mailbox',
		fields: {
			message_count: `Number of messages indexed.`,
			first_uid: `UID of the first indexed message.`,
			last_uid: `UID of the last indexed message.`,
			user_cpu_usecs: `Total user CPU spent on the indexing transaction in microseconds.`,
		},
		text: `Indexer worker process completed an indexing transaction.`
	},

	/* Mail Index Cache */

	mail_cache_decision_changed: {
		root: 'mail-cache',
		inherit: 'mail_index_common',
		fields: {
			field: `Cache field name (e.g. \`imap.body\` or \`hdr.from\`).`,
			last_used: `UNIX timestamp of when the field was accessed the last time. This is updated only once per 24 hours.`,
			reason: `
Reason why the caching decision changed:
* \`add\`: no -&gt; temp decision change, because a new field was added to cache.
* \`old_mail\`: temp -&gt; yes decision change, because a mail older than 1 week was accessed.
* \`unordered_access\`: temp -&gt; yes decision change, because mails weren't accessed in ascending order.
* Other values indicate a reason for cache purging, which changes the caching decision yes -&gt; temp.`,
			uid: `IMAP UID number that caused the decision change. This is set only for some reasons, not all.`,
			old_decision: `Old <a href="#mail_cache_decision_changed_decisions">cache decision</a>.`,
			new_decision: `New <a href="#mail_cache_decision_changed_decisions">cache decision</a>.`,
		},
		text: `
A field's caching decision changed.

<span id="mail_cache_decision_changed_decisions" />

Decisions:

| Decision | Description |
| -------- | ----------- |
| \`no\` | The field is not cached. |
| \`temp\` | The field is cached for 1 week and dropped on the next purge. |
| \`yes\` | The field is cached permanently. If the field isn't accessed for 30 days it's dropped. |`
	},

	mail_cache_decision_rejected: {
		root: 'mail-cache',
		fields: {
			field: `Cache field name (e.g. \`hdr.from\`).`,
			reason: `
Reason why the caching decision changed:
* \`too_many_headers\`
:   This can happen when the count of headers in the cache exceeds the maximum configured with [[setting,mail_cache_max_headers_count]].`,
		},
		text: `
The decision to promote a field (from \`no\` to \`temp\`) was rejected.`
	},

	mail_cache_purge_started: {
		root: 'mail-cache',
		inherit: [ 'mail_cache_purge', 'mail_index_common' ],
		text: `Cache file purging is started.`
	},

	mail_cache_purge_drop_field: {
		root: 'mail-cache',
		inherit: [ 'mail_cache_purge', 'mail_index_common' ],
		fields: {
			field: `Cache field name (e.g. \`imap.body\` or \`hdr.from\`).`,
			decision: `Old caching decision: \`temp\`, or \`yes\`.`,
			last_used: `UNIX timestamp of when the field was accessed the last time. This is updated only once per 24 hours.`,
		},
		text: `
Existing field is dropped from the cache file because it hadn't been accessed
for 30 days.`
	},

	mail_cache_purge_finished: {
		root: 'mail-cache',
		inherit: [ 'mail_cache_purge', 'mail_index_common' ],
		fields: {
			file_size: `Size of the new cache file.`,
			max_uid: `IMAP UID of the last mail in the cache file.`,
		},
	},

	mail_cache_corrupted: {
		root: 'mail-cache',
		inherit: 'mail_index_common',
		fields: {
			reason: `Reason string why cache was found to be corrupted.`,
		},
		text: `
Cache file was found to be corrupted and the whole file is deleted.`
	},

	mail_cache_record_corrupted: {
		root: 'mail-cache',
		inherit: 'mail_index_common',
		fields: {
			reason: `Reason string why cache was found to be corrupted.`,
			uid: `IMAP UID of the mail whose cache record is corrupted.`,
		},
		text: `
Cache record for a specific mail was found to be corrupted and the record
is deleted.`
	},

	/* HTTP Client
	 *
	 * These events are emitted by Dovecot's internal HTTP library when
	 * acting as a client to an external service. */

	http_request_finished: {
		root: 'http-client',
		inherit: 'http_client',
		text: `
HTTP request is complete.

This event is useful to track and monitor external services.`
	},

	http_request_redirected: {
		root: 'http-client',
		inherit: 'http_client',
		text: `
Intermediate event emitted when an HTTP request is being redirected.

The [[event,http_request_finished]] is still sent at the end of the request.`
	},

	http_request_retried: {
		root: 'http-client',
		inherit: 'http_client',
		text: `
Intermediate event emitted when an HTTP request is being retried.

The [[event,http_request_finished]] is still sent at the end of the request.`
	},

	/* HTTP Server
	 *
	 * These events are emitted by Dovecot's internal HTTP library when
	 * serving requests (e.g. doveadm HTTP API). */

	http_server_request_started: {
		root: 'http-server',
		inherit: 'http_server',
		text: `
A new HTTP request has been received and the request headers (but not body
payload) are parsed.`
	},

	http_server_request_finished: {
		root: 'http-server',
		inherit: 'http_server',
		fields: {
			net_in_bytes: {
				changed: {
					events_net_in_bytes_changed: `This was previously \`in_bytes\`.`
				},
				text: `Amount of request data read, in bytes.`
			},
			net_out_bytes: {
				changed: {
					events_net_out_bytes_changed: `This was previously \`out_bytes\`.`
				},
				text: `Amount of response data written, in bytes.`
			},
			status_code: `HTTP result status code (integer).`,
		},
		text: `
HTTP request is fully completed, i.e. the incoming request body is read and
the full response to the request has been sent to the client.`
	},

	/* POP3 */

	pop3_command_finished: {
		root: 'pop3',
		inherit: 'pop3_command',
		added: {
			events_pop3_command_finished_added: false,
		},
		fields: {
			reply: `
POP3 reply. Values:
* \`OK\`
* \`FAIL\``,
			net_in_bytes: `Amount of data read for this command, in bytes.`,
			net_out_bytes: `Amount of data written for this command, in bytes.`,
		},
		text: `
POP3 command is completed.

This event is useful to track individual command usage, debug specific
sessions, and/or detect broken clients.

::: tip Note
This event is currently not sent for pre-login POP3 commands.
:::`
	},


	/* IMAP Client */

	imap_client_hibernated: {
		root: 'imap-hibernate',
		inherit: 'imap_client',
		fields: {
			mailbox: `Mailbox name where hibernation was started in.`,
			error: `Reason why hibernation attempt failed.`,
		},
		text: `
IMAP client is hibernated or the hibernation attempt failed.

::: tip Note
For failures, this event can be logged by either imap or imap-hibernate
process depending on which side the error was detected in.
:::`
	},

	imap_client_unhibernated: {
		root: 'imap-hibernate',
		inherit: 'imap_client',
		fields: {
			mailbox: `Mailbox name where hibernation was started in.`,
			reason: `
Reason why client was unhibernated:
* \`idle_done\`: IDLE command was stopped with DONE.
* \`idle_bad_reply\`: IDLE command was stopped with some other command than DONE.
* \`mailbox_changes\`: Mailbox change notifications need to be sent to the client.`,
			hibernation_usecs: `Number of microseconds how long the client was hibernated.`,
		},
		text: `
IMAP client is unhibernated or the unhibernation attempt failed.

::: tip Note
For failures, this event can be logged by either imap or imap-hibernate
process depending on which side the error was detected in.
:::`
	},

	imap_client_unhibernate_retried: {
		root: 'imap-hibernate',
		inherit: 'imap_client',
		fields: {
			error: `Reason why unhibernation failed.`
		},
		text: `
An IMAP client is attempted to be unhibernated, but imap processes are busy
and the unhibernation attempt is retried.

This event is sent each time when retrying is done.

The [[event,imap_client_unhibernated]] event is still sent when unhibernation
either succeeds or fails permanently.`
	},

	/* IMAP Command */

	imap_command_finished: {
		root: 'imap',
		inherit: 'imap_command',
		fields: {
			tagged_reply_state: `
Values:
* \`OK\`
* \`NO\`
* \`BAD\``,
			tagged_reply: `Full tagged reply (e.g. \`OK SELECT finished.\`).`,
			last_run_time: `Timestamp when the command was running last time. (Command may be followed by internal "mailbox sync" that can take some time to complete.)`,
			running_usecs: `How many usecs this command has spent running.`,
			lock_wait_usecs: `How many usecs this command has spent waiting for locks.`,
			net_in_bytes: {
				changed: {
					events_net_in_bytes_changed: `This was previously \`in_bytes\`.`
				},
				text: `Amount of data read for this command, in bytes.`
			},
			net_out_bytes: {
				changed: {
					events_net_out_bytes_changed: `This was previously \`out_bytes\`.`
				},
				text: `Amount of data written for this command, in bytes.`
			},
		},
		text: `
IMAP command is completed.

This event is useful to track individual command usage, debug specific
sessions, and/or detect broken clients.

::: tip Note
This event is currently not sent for pre-login IMAP commands.
:::`
	},

	imap_id_received: {
		root: 'imap',
		inherit: 'imap_command',
		added: {
			events_imap_id_received_added: false,
		},
		fields: {
			'id_param_<param>': `
Received parameters. The event name is the lowercase parameter key prefixed
with \`id_param_\`, the value is the parameter value.`,
			'id_invalid<num>': `
Each key that contains invalid characters are enumerated starting with 1.
Valid characters are latin alphabetic characters (= \`a\` .. \`z\`),
numerals (= \`0\` .. \`9\`), the dash (= \`-\`) and
the underscore (= \`_\`), every other character is
considered invalid. The value of this field is the
original parameter key including invalid characters,
followed by a space character, and finally the
original value concatenated into a single string.`,
		},
		text: `
This event is emitted when the IMAP ID command was received, both for pre-
as well as post-login. The parameters slightly differ for an unauthenticated
client, e.g. there is no user id.`
	},

	/* Mail Delivery
	 *
	 * Events emitted on mail delivery. */

	mail_delivery_started: {
		root: 'local-delivery',
		inherit: 'mail_delivery',
		text: `
Message delivery has started.

This event is useful for debugging mail delivery flow.`,
	},

	mail_delivery_finished: {
		root: 'local-delivery',
		inherit: 'mail_delivery',
		fields: {
			error: `Error message if the delivery failed.`,
		},
		text: `
Message delivery is completed.

This event is useful for logging and tracking mail deliveries.`
	},

	/* DNS
	 *
	 * Events emitted from Dovecot's internal DNS client. */

	dns_worker_request_started: {
		root: 'dns-worker',
		text: `DNS request started being processed by DNS worker process.`
	},

	dns_request_started: {
		root: 'dns-client',
		text: `DNS request sent by DNS client library to DNS worker process.`
	},

	dns_worker_request_finished: {
		root: 'dns-worker',
		inherit: 'dns',
		fields: {
			cached: {
				added: {
					events_dns_worker_request_finished_cached_added: false
				},
				text: `Set to \`yes\` or \`no\` depending if it was a cached reply or not.`,
			},
		},
		text: `DNS request finished being processed by DNS worker process.`
	},

	dns_request_finished: {
		root: 'dns-client',
		inherit: 'dns',
		text: `
DNS request sent by DNS client library to DNS worker process has been
finished.`
	},

	/* SQL
	 *
	 * Events emitted by Dovecot's internal SQL library.
	 * Note: This includes queries sent to Cassandra. */

	sql_query_finished: {
		root: 'sql',
		fields: {
			error: `Human readable error.`,
			error_code: `Error code (if available).`,
			query_first_word: `First word of the query (e.g. \`SELECT\`).`,
			consistency: {
				added: {
					events_sql_query_finished_consistency_added: false
				},
				text: `Requested consistency for the query (Cassandra only).`
			},
			error_consistency: {
				added: {
					events_sql_query_finished_consistency_added: false
				},
				text: `Consistency attempted to be used by Cassandra for the failed query (Cassandra only).`
			},
		},
		text: `Response was received to SQL query.`
	},

	sql_transaction_finished: {
		root: 'sql',
		fields: {
			error: `Human readable error.`,
			error_code: `Error code (if available).`,
		},
		text: `SQL transaction was committed or rolled back.`
	},

	sql_connection_finished: {
		root: 'sql',
		text: `Connection to SQL server is closed.`
	},

	/* SMTP Server
	 *
	 * These events are emitted by Dovecot's internal lib-smtp library. */

	smtp_server_command_started: {
		root: 'smtp-server',
		inherit: 'smtp_server',
		text: `The command is received from the client.`
	},

	smtp_server_command_finished: {
		root: 'smtp-server',
		inherit: 'smtp_server',
		fields: {
			status_code: `SMTP status code for the (first) reply. This is = 9000 for aborted commands (e.g., when the connection is closed prematurely).`,
			enhanced_code: `SMTP enhanced status code for the (first) reply. This is "9.0.0" for aborted commands (e.g., when the connection is closed prematurely).`,
			error: `Error message for the reply. There is no field for a success message.`,
		},
		text: `
The command is finished. Either a success reply was sent for it or it
failed somehow.`
	},


	/* SMTP Transaction */

	smtp_server_transaction_started: {
		root: 'smtp-server',
		inherit: 'smtp_transaction',
		text: `The transaction is started.`
	},

	smtp_server_transaction_finished: {
		root: 'smtp-server',
		inherit: 'smtp_transaction',
		fields: {
			status_code: `SMTP status code for the (first failure) reply. This is = 9000 for aborted commands (e.g., when the connection is closed prematurely).`,
			enhanced_code: `SMTP enhanced status code for the (first failure) reply. This is "9.0.0" for aborted commands (e.g., when the connection is closed prematurely).`,
			error: `Error message for the first failure reply. There is no field for a success message.`,
			recipients: `Total number of recipients.`,
			recipients_aborted: `
The number of recipients that got aborted before these could either finish
or fail. This means that the transaction failed early somehow while these
recipients were still being processed by the server.`,
			recipients_denied: `The number of recipients denied by the server using a negative reply to the RCPT command.`,
			recipients_failed: `The number of recipients that failed somehow (includes denied recipients, but not aborted recipients).`,
			recipients_succeeded: `The number of recipients for which the transaction finally succeeded.`,
			is_reset: `
The transaction was reset (RSET) rather than finishing
with a DATA/BDAT command as it normally would. This happens when client
side issues the RSET command. Note that a reset event is a success (no
error field is present).`,
		},
		text: `Transaction is finished or failed.`
	},

	/* SMTP Recipient */

	smtp_server_transaction_rcpt_finished: {
		root: 'smtp-server',
		inherit: 'smtp_recipient',
		fields: {
			status_code: `SMTP status code for the reply. This is = 9000 for aborted commands (e.g., when the connection is closed prematurely).`,
			enhanced_code: `SMTP enhanced status code for the reply. This is "9.0.0" for aborted commands (e.g., when the connection is closed prematurely).`,
			error: `Error message for the reply if it is a failure. There is no field for a success message.`,
			dest_host: {
				added: {
					events_smtp_server_transaction_rcpt_finished_dest_host_added: false,
				},
				text: `LMTP proxying only: Proxy destination hostname.`,
			},
			dest_ip: {
				added: {
					events_smtp_server_transaction_rcpt_finished_dest_ip_added: false,
				},
				text: `LMTP proxying only: Proxy destination IP address.`,
			},
		},
		text: `
The transaction is finished or failed for this particular recipient. When
successful, this means the DATA command for the transaction yielded success
for that recipient (even for SMTP this event is generated for each
recipient separately). Recipients can fail at various stages, particularly
at the actual RCPT command where the server can deny the recipient.`
	},

	/* SMTP Submit
	 *
	 * These events are emitted by Dovecot's internal lib-smtp library
	 * when sending mails. */

	smtp_submit_started: {
		root: 'smtp-submit',
		text: `Started message submission.`
	},

	smtp_submit_finished: {
		root: 'smtp-submit',
		inherit: 'smtp_submit',
		fields: {
			error: `Error message for submission failure.`,
		},
		text: `Finished the message submission.`
	},

	/* Push Notifications */

	push_notification_finished: {
		root: 'push-notification',
		inherit: 'mail_user',
		fields: {
			mailbox: `Mailbox for event.`,
		},
		text: `
Push notification event was sent. See [[link,stats_push_notifications]].`
	},

	/* Sieve Runtime */

	sieve_runtime_script_started: {
		root: 'sieve-runtime',
		inherit: 'sieve_runtime',
		text: `Started evaluating a Sieve script.`
	},

	sieve_runtime_script_finished: {
		root: 'sieve-runtime',
		inherit: 'sieve_runtime',
		text: `Finished evaluating a Sieve script.`
	},

	/* Sieve Action */

	sieve_action_finished: {
		root: 'sieve-execute',
		inherit: 'sieve_execute',
		fields: {
			action_name: `
| Action | Description |
| ------ | ----------- |
| \`discard\` | The discard action was executed successfully (only has an effect when no explicit keep is executed). |
| \fileinto\` | The fileinto action was executed successfully. |
| \`keep\` | The keep action was executed successfully (maps to fileinto internally, so the fields are identical). |
| \`notify\` | The notify action was executed successfully (either from the notify or the enotify extension). |
| \`pipe\` | The pipe action (from vnd.dovecot.pipe extension) was executed successfully. |
| \`redirect\` | The redirect action was executed successfully. |
| \`reject\` | The reject action was executed successfully. |
| \`report\` | The report action (from vnd.dovecot.report extension) was executed successfully. |
| \`vacation\` | The vacation action was executed successfully. |`,
			action_script_location: `
The location string for this Sieve action (a combination of "&lt;script-name&gt;: line &lt;number&gt;".`,
			redirect_target: `The target address for the redirect action.`,
			notify_target: `The list of target addresses for the notify action.`,
			report_target: `The target address for the report action.`,
			report_type: `The feedback type for the report action.`,
			fileinto_mailbox: `The target mailbox for the fileinto/keep action.`,
			pipe_program: `The name of the program being executed by the pipe action.`,
		},
		text: `Emitted when sieve action is completed successfully.`
	},

	/* Sieve Storage */

	sieve_script_opened: {
		root: 'sieve-storage',
		inherit: 'sieve_storage',
		text: `
Opened a Sieve script for reading (e.g. for ManageSieve GETSCRIPT or
compiling it at delivery).`
	},


	sieve_script_closed: {
		root: 'sieve-storage',
		inherit: 'sieve_storage',
		text: `Closed a Sieve script (after reading it).`
	},

	sieve_script_deleted: {
		root: 'sieve-storage',
		inherit: 'sieve_storage',
		text: `Deleted a Sieve script.`
	},

	sieve_script_activated: {
		root: 'sieve-storage',
		inherit: 'sieve_storage',
		text: `Activated a Sieve script.`
	},

	sieve_script_renamed: {
		root: 'sieve-storage',
		inherit: 'sieve_storage',
		fields: {
			old_script_name: `Old name of the Sieve script.`,
			new_script_name: `New name for the Sieve script.`,
		},
		text: `Renamed a Sieve script.`
	},

	sieve_storage_save_started: {
		root: 'sieve-storage',
		inherit: 'sieve_storage',
		fields: {
			script_name: `Name of the Sieve script.`,
		},
		text: `Started saving a Sieve script.`
	},

	sieve_storage_save_finished: {
		root: 'sieve-storage',
		inherit: 'sieve_storage',
		fields: {
			script_name: `Name of the Sieve script.`,
		},
		text: `Finished saving a Sieve script.`
	},

	/* ManageSieve */

	managesieve_command_finished: {
		root: 'managesieve',
		inherit: 'managesieve',
		fields: {
			script_name: `Name for the Sieve script this command operated on (if any).`,
			old_script_name: `Old name of the Sieve script (only set for RENAMESCRIPT).`,
			new_script_name: `New name for the Sieve script (only set for RENAMESCRIPT).`,
			compile_errors: `The number of compile errors that occurred (only set for PUTSCRIPT, CHECKSCRIPT and SETACTIVE when compile fails).`,
			compile_warnings: `The number of compile warnings that occurred (only set for PUTSCRIPT, CHECKSCRIPT and SETACTIVE when script is compiled).`,
		},
		text: `Finished the ManageSieve command.`
	},

	/* Dictionaries
	 *
	 * Events emitted by dictionary library and dictionary server. */

	dict_created: {
		root: 'dict',
		inherit: 'dict_init',
		text: `Dictionary is initialized.`
	},

	dict_destroyed: {
		root: 'dict',
		inherit: 'dict_init',
		text: `Dictionary is destroyed.`
	},

	dict_lookup_finished: {
		root: 'dict',
		inherit: 'dict_lookup',
		text: `Dictionary lookup finishes.`
	},

	dict_iteration_finished: {
		root: 'dict',
		inherit: 'dict_iteration',
		text: `Dictionary iteration finished.`
	},

	dict_transaction_finished: {
		root: 'dict',
		inherit: 'dict_transaction',
		text: `Dictionary transaction has been committed or rolled back.`
	},

	dict_server_lookup_finished: {
		root: 'dict-server',
		inherit: 'dict_lookup',
		text: `Dictionary server finishes lookup.`
	},

	dict_server_iteration_finished: {
		root: 'dict-server',
		inherit: 'dict_iteration',
		text: `Dictionary server finishes iteration.`
	},

	dict_server_transaction_finished: {
		root: 'dict-server',
		inherit: 'dict_transaction',
		text: `Dictionary server finishes transaction.`
	},

	/* Login */

	login_aborted: {
		added: {
			events_login_aborted_added: false,
		},
		inherit: 'pre_login_client',
		fields: {
			reason: `Short reason; see the <a href="#pre_login_client_reason_values">short reason to description mapping</a>.`,
			auth_successes: `Number of successful authentications, which eventually failed due to other reasons.`,
			auth_attempts: `Total number of authentication attempts, both successful and failed.`,
			auth_usecs: `How long ago the first authentication attempt was started.`,
			connected_usecs: `How long ago the client connection was created.`,
		},
		text: `
<span id="pre_login_client_reason_values" />

\`reason\` values:

| Reason | Description |
| ------ | ----------- |
| \`anonymous_auth_disabled\` | Anonymous authentication is not allowed. |
| \`authorization_failed\` | Master user authentication succeeded, but authorization to access the requested login user wasn't allowed. |
| \`auth_aborted_by_client\` | Client started SASL authentication, but returned "*" reply to abort it. |
| \`auth_failed\` | Generic authentication failure. Possibly due to invalid username/password, but could have been some other unspecified reason also. |
| \`auth_nologin_referral\` | Authentication returned auth referral to redirect the client to another server. This is normally configured to be sent only when the client is a Dovecot proxy, which handles the redirection. |
| \`auth_process_comm_fail\` | Internal error communicating with the auth process. |
| \`auth_process_not_ready\` | Client disconnected before auth process was ready. This may indicate a hanging auth process if \`connected_usecs\` is large. |
| \`auth_waiting_client\` | Client started SASL authentication, but disconnected instead of sending the next SASL continuation reply. |
| \`cleartext_auth_disabled\` | Authentication using cleartext mechanism is not allowed at this point. It would be allowed if SSL/TLS was enabled. |
| \`client_ssl_cert_untrusted\` | Client sent an SSL certificate that is untrusted with [[setting,auth_ssl_require_client_cert,yes]]. |
| \`client_ssl_cert_missing\` | Client didn't send SSL certificate, but [[setting,auth_ssl_require_client_cert,yes]]. |
| \`client_ssl_not_started\` | Client didn't even start SSL with [[setting,auth_ssl_require_client_cert,yes]]. |
| \`connection_limit\` | Client reached [[setting,mail_max_userip_connections]] limit. |
| \`internal_failure\` | Internal failure. The error log has more details. |
| \`invalid_base64\` | Client sent invalid base64 in SASL response. |
| \`invalid_mech\` | Unknown SASL authentication mechanism requested. |
| \`login_disabled\` | The user has the [[link,auth_nologin]] field set in passdb and is thereby not able to login. |
| \`no_auth_attempts\` | Client didn't send any authentication attempts. |
| \`password_expired\` | The user's password is expired.
| \`process_full\` | [[link,service_client_limit]] and [[link,service_process_limit]] was hit and this login session was killed. |
| \`shutting_down\` | The process is shutting down so the login is aborted. |
| \`tls_handshake_not_finished\` | TLS handshake failed or was not finished. |
| \`user_disabled\` | User is in deny passdb, or in some other way disabled passdb. |

Proxying \`reason\` values:

| Reason | Description |
| ------ | ----------- |
| \`proxy_dest_connect_failed\` | Local authentication succeeded, but connection to destination hop failed. |
| \`proxy_dest_internal_failure\` | Local authentication succeeded, but internal failure occurred after that. |
| \`proxy_dest_remote_failure\` | Local authentication succeeded, but destination hop reported unspecified failure. |
| \`proxy_dest_protocol_failure\` | Local authentication succeeded, but destination hop unexpectedly violated the protocol standard. |
| \`proxy_dest_auth_failed\` | Local authentication succeeded, but proxying failed to authenticate to the destination hop. |
| \`proxy_dest_auth_temp_failed\` | Local authentication succeeded, but proxying failed to temporarily authenticate to the destination hop. |
| \`proxy_dest_redirected\` | Local authentication succeeded, but destination hop redirected to another host. |`
	},

	/* Login Proxy
	 *
	 * Events emitted when login process proxies a connection to a backend. */

	proxy_session_started: {
		inherit: 'login_proxy',
		text: `Connection to proxy destination has started.`
	},

	proxy_session_established: {
		inherit: 'login_proxy_session',
		text: `
Connection to proxy destination is established and user is successfully
logged into the backend.`
	},

	proxy_session_finished: {
		inherit: 'login_proxy_session',
		fields: {
			error: `If login to destination failed, contains the error.`,
			error_code: {
				added: {
					events_proxy_session_finished_error_code_added: false
				},
				text: `If login to destination failed, contains the <a href="#proxy_session_finished_error_code">error code</a>.`,
			},
			disconnect_side: `Which side disconnected: \`client\`, \`server\`, \`proxy\`.`,
			disconnect_reason: `Reason for disconnection (empty = clean disconnect).`,
			idle_usecs: {
				changed: {
					events_proxy_session_finished_idle_usecs_changed: `This was previously named \`idle_secs\`.`
				},
				text: `Number of seconds the connection was idling before getting disconnected.`
			},
			net_in_bytes: {
				changed: {
					events_net_in_bytes_changed: `This was previously \`in_bytes\`.`
				},
				text: `Amount of data read from client, in bytes.`
			},
			net_out_bytes: {
				changed: {
					events_net_out_bytes_changed: `This was previously \`out_bytes\`.`
				},
				text: `Amount of data written to client, in bytes.`
			},
		},
		text: `
Connection to proxy destination has ended, either successfully or with error.

<span id="proxy_session_finished_error_code" />

List of error codes:

| Error Code | Explanation |
| ---------- | ----------- |
| \`authorization_failed\` | User authorization failed. |
| \`temp_fail\` | Auth service reported temporary failure. |
| \`user_disabled\` | User is disabled. |
| \`password_expired\` | Password is expired. |
| \`invalid_base64\` | Challenge response was invalid base64 encoded. |
| \`login_disabled\` | Login is disabled. |
| \`invalid_mech\` | Used mechanism isn't supported. |
| \`cleartext_auth_disabled\` | Cleartext authentication is not enabled, use TLS. |
| \`anonymous_auth_disabled\` | Anonymous authentication is not enabled. |

Proxying error codes:

| Reason | Description |
| ------ | ----------- |
| \`proxy_dest_connect_failed\` | Local authentication succeeded, but connection to destination hop failed. |
| \`proxy_dest_internal_failure\` | Local authentication succeeded, but internal failure occurred after that. |
| \`proxy_dest_remote_failure\` | Local authentication succeeded, but destination hop reported unspecified failure. |
| \`proxy_dest_protocol_failure\` | Local authentication succeeded, but destination hop unexpectedly violated the protocol standard. |
| \`proxy_dest_auth_failed\` | Local authentication succeeded, but proxying failed to authenticate to the destination hop. |
| \`proxy_dest_auth_temp_failed\` | Local authentication succeeded, but proxying failed to temporarily authenticate to the destination hop. |
| \`proxy_dest_redirected\` | Local authentication succeeded, but destination hop redirected to another host. |`
	},

}

/* 'Global Inherits': All events inherit these fields. */
export const global_inherits = {
	// KEY: field name, VALUE: field description (processed w/Markdown)
	duration: `Duration of the event (in microseconds)`,
	reason_code: `List of reason code strings why the event happened. See [event reasons](events#event-reasons) for possible values.`,
}

/* 'Inherited Events': Events that aren't emitted on its own, but child events
 * can inherit fields from. */
export const inherits = {
	auth_client_common: {
		fields: {
			mechanism: `Name of used SASL mechanism (e.g. PLAIN).`,
			service: `Name of service. Examples: \`imap\`, \`pop3\`, \`lmtp\`, ...`,
			transport: `
Transport security indicator. Values:

* \`insecure\`
* \`secured\`
  * [[changed,auth_client_common_secured]] Secure non-TLS connections (e.g. from localhost) are now \`secured\` rather than \`trusted\`.
* \`TLS\``,
			session: `Session identifier.`,
			certificate_user: `Username from certificate.`,
			client_id: `Expands to client ID request as IMAP arglist. Needs [[setting,imap_id_retain,yes]].`,
			local_name: `TLS SNI.`,
			local_ip: `Local IP client connected to.`,
			remote_ip: `Remote IP of client.`,
			local_port: `Local port client connected to.`,
			remote_port: `Remote port of client.`,
			real_local_ip: `Real local IP as seen by the server.`,
			real_remote_ip: `Real remote IP as seen by the server.`,
			real_local_port: `Real local port as seen by the server.`,
			real_remote_port: `Real remote port as seen by the server.`,
			tls_cipher: `Cipher name used, e.g. \`TLS_AES_256_GCM_SHA384\`.`,
			tls_cipher_bits: `Cipher bits, e.g. \`256\`.`,
			tls_pfs: `Perfect forward-security mechanism, e.g. \`KxANY\`, \`KxECDHE\`.`,
			tls_protocol: `TLS protocol name, e.g. \`TLSv1.3\`.`,
		}
	},

	auth_client_lookup: {
		inherit: 'auth_client_common',
		fields: {
			user: `Full username to lookup.`,
			error: `Error string, if error occurred.`,
		}
	},

	auth_client_request: {
		inherit: 'auth_client_common',
		fields: {
			user: `Username, if present.`,
			original_user: `Original username, if present.`,
			auth_user: `Auth username, if present.`,
			error: `Error string, if error occurred.`,
		}
	},

	auth_server_common: {
		fields: {
			user: `Full username. This can change during authentication, for example due to passdb lookups.`,
			original_user: `Original username exactly as provided by the client.`,
			translated_user: `Similar to \`original_user\`, except after [[setting,auth_username_translation]] translations are applied.`,
			login_user: `When doing a master user login, the user we are logging in as. Otherwise not set.`,
			master_user: `When doing a master user login, the master username. Otherwise not set.`,
			mechanism: `Name of used SASL mechanism (e.g. PLAIN).`,
			service: `Service doing the lookup (e.g. \`imap\`, \`pop3\`, ...).`,
			session: `Session ID.`,
			client_id: `Expands to client ID request as IMAP arglist. Needs [[setting,imap_id_retain,yes]].`,
			remote_ip: `Remote IP address of the client connection.`,
			local_ip: `Local IP address where client connected to.`,
			remote_port: `Remote port of the client connection.`,
			local_port: `Local port where the client connected to.`,
			real_remote_ip: `Same as \`remote_ip\`, except if the connection was proxied this is the proxy's IP address.`,
			real_local_ip: `Same as \`local_ip\`, except if the connection was proxied this is the proxy's IP where proxy connected to.`,
			real_remote_port: `Same as \`remote_port\`, except if the connection was proxied this is the proxy connection's port.`,
			real_local_port: `Same as \`local_port\`, except if the connection was proxied this is the local port where the proxy connected to.`,
			local_name: `TLS SNI hostname, if given.`,
			transport: `
Transport security indicator. Values:

* \`insecure\`
* \`secured\`
  * [[changed,auth_server_common_secured]] Secure non-TLS connections (e.g. from localhost) are now \`secured\` rather than \`trusted\`.
* \`TLS\``,
		}
	},

	auth_server_passdb: {
		fields: {
			passdb: `Driver name.`,
			passdb_name: `\`passdb { name }\`, if it is configured. Otherwise, same as \`passdb { driver }\`.`,
			passdb_id: `Internal ID number of the passdb. May be useful to identify the passdb if it has no name.`,
		}
	},

	auth_server_userdb: {
		fields: {
			userdb: `Driver name.`,
			userdb_name: `\`userdb { name }\`, if it is configured. Otherwise, same as \`userdb { driver }\`.`,
			userdb_id: `Internal ID number of the userdb. May be useful to identify the userdb if it has no name.`
		}
	},

	auth_master_common: {
		fields: {
			id: `Login request ID.`,
			local_ip: `Client connection's local (server) IP.`,
			local_port: `Client connection's local (server) port.`,
			remote_ip: `Client connection's remote (client) IP.`,
			remote_port: `Client connection's remote (client) port.`,
		},
	},

	client_connection_common: {
		fields: {
			local_ip: `Local server IP address where TCP client connected to.`,
			remote_ip: `Remote TCP client's IP address.`,
			remote_port: `Remote TCP client's source port.`,
			remote_pid: `Remote UNIX socket client's process ID.`,
			remote_uid: `Remote UNIX socket client's system user ID.`,
		}
	},

	server_connection_common: {
		fields: {
			source_ip: `Source IP address used for the outgoing TCP connection. This is set only if a specific source IP was explicitly requested.`,
			dest_ip: `TCP connection's destination IP address.`,
			dest_port: `TCP connection's destination port.`,
			dest_host: `TCP connection's destination hostname, if known.`,
			socket_path: `UNIX socket connection's path.`,
			remote_pid: `Remote UNIX socket server's process ID.`,
			remote_uid: `Remote UNIX socket server's system user ID.`,
		}
	},

	mail_storage_service_user: {
		fields: {
			// TODO: Inherits from environment (e.g. IMAP/LMTP client)
			session: `Session ID for the storage session.`,
			service: {
				added: {
					events_mail_storage_service_user_service_added: false
				},
				text:`Name of the service. Examples: \`imap\`, \`pop3\`, \`lmtp\`, ...`
			},
		}
	},

	mail_user: {
		inherit: 'mail_storage_service_user',
		fields: {
			user: `Username of the user.`
		}
	},

	mailbox: {
		inherit: 'mail_user',
		fields: {
			mailbox: `Full mailbox name in UTF-8`,
			mailbox_guid: `Mailbox GUID`
		}
	},

	mail: {
		fields: {
			seq: `Mail sequence number.`,
			uid: `Mail IMAP UID number.`,
		}
	},

	mail_index_common: {
		fields: {}
	},

	mail_cache_purge: {
		fields: {
			file_seq: `Sequence of the new cache file that is created.`,
			prev_file_seq: `Sequence of the cache file that is to be purged.`,
			prev_file_size: `Size of the cache file that is to be purged.`,
			prev_deleted_records: `Number of records (mails) marked as deleted in the cache file that is to be purged.`,
			reason: `
Reason string for purging the cache file:
* doveadm mailbox cache purge
* copy cache decisions
* creating cache
* cache is too large
* syncing
* rebuilding index`,
		},
	},

	http_client: {
		fields: {
			attempts: `Amount of individual HTTP request attempts (number of retries after failures + 1).`,
			net_in_bytes: {
				changed: {
					events_net_in_bytes_changed: `This was previously \`in_bytes\`.`
				},
				text: `Amount of data read, in bytes.`
			},
			net_out_bytes: {
				changed: {
					events_net_out_bytes_changed: `This was previously \`out_bytes\`.`
				},
				text: `Amount of data written, in bytes.`
			},
			dest_host: `Destination host.`,
			dest_ip: `Destination IP address.`,
			dest_port: `Destination port.`,
			method: `HTTP verb used uppercased, e.g. \`GET\`.`,
			redirects: `Number of redirects done while processing request.`,
			status_code: `HTTP result status code (integer).`,
			target:	`Request path with parameters, e.g. \`/path/?delimiter=%2F&prefix=test%2F\`.`,
		}
	},

	http_server: {
		inherit: 'client_connection_common',
		fields: {
			request_id: `Assigned ID of the received request.`,
			method: `HTTP verb used uppercased, e.g. \`GET\`.`,
			target: `Request path with parameters, e.g. \`/path/?delimiter=%2F&prefix=test%2F\`.`,
		}
	},

	pop3_client: {
		fields: {
			user: `Username of the user.`,
			session: `Session ID of the POP3 connection.`,
			local_ip: `POP3 connection's local (server) IP.`,
			local_port: `POP3 connection's local (server) port.`,
			remote_ip: `POP3 connection's remote (client) IP.`,
			remote_port: `POP3 connection's remote (client) port.`
		},
	},

	pop3_command: {
		inherit: 'pop3_client',
		fields: {
			cmd_name: `POP3 command name uppercased (e.g. \`UIDL\`).`,
			cmd_args: `POP3 command's full parameters (e.g. \`1 1\`).`,
		},
	},

	imap_client: {
		fields: {
			user: `Username of the user.`,
			session: `Session ID of the IMAP connection.`,
			local_ip: `IMAP connection's local (server) IP.`,
			local_port: `IMAP connection's local (server) port.`,
			remote_ip: `IMAP connection's remote (client) IP.`,
			remote_port: `IMAP connection's remote (client) port.`,
		},
	},

	imap_command: {
		inherit: 'imap_client',
		fields: {
			cmd_tag: `IMAP command tag.`,
			cmd_name: `
IMAP command name uppercased (e.g. \`FETCH\`).

Contains \`unknown\` for unknown command names.`,
			cmd_input_name: `IMAP command name exactly as sent (e.g. \`fetcH\`) regardless of whether or not it is valid.`,
			cmd_args: `IMAP command's full parameters (e.g.  \`1:* FLAGS\`).`,
			cmd_human_args: `
IMAP command's full parameters, as human-readable output. Often it's the
same as \`cmd_args\`, but it is guaranteed to contain only valid UTF-8
characters and no control characters.

 Multi-line parameters are written only as \`<N byte multi-line literal>\`.`
		},
	},

	mail_delivery: {
		inherit: 'smtp_recipient',
		fields: {
			message_id: `Message-ID header value (truncated to 200 bytes).`,
			message_subject: `Subject header value, in UTF-8 (truncated to 80 bytes).`,
			message_from: `Email address in the From header (e.g. \`user@example.com\`).`,
			message_size: `Size of the message, in bytes.`,
			message_vsize: `Size of the message with CRLF linefeeds, in bytes.`,
			rcpt_to: `The envelope recipient for the message.`,
		},
	},

	dns: {
		fields: {
			error: `Human readable error.`,
			error_code: `Error code usable with net_gethosterror().`,
		},
	},

	smtp_connection: {
		// TODO: Inherits from environment (LDA, LMTP or IMAP)
		fields: {
			connection_id: `The session ID for this connection. The connection ID is forwarded through proxies, allowing correlation between sessions on frontend and backend systems.`,
			protocol: `The protocol used by the connection; i.e., either \`smtp\` or \`lmtp\`.`,
			session: `The session ID for this connection (same as \`connection_id\`).`,
		},
	},

	smtp_server: {
		inherit: 'smtp_connection',
		fields: {
			cmd_name: `Name of the command.`,
			cmd_input_name: `SMTP command name exactly as sent (e.g. \`MaIL\`) regardless of whether or not it is valid.`,
			cmd_args: `SMTP command's full parameters (e.g. \`<from@example.com>\`).`,
			cmd_human_args: `SMTP command's full parameters, as human-readable output. For SMTP, this is currently identical to \`cmd_args\`.`,
		},
	},

	smtp_transaction: {
		inherit: 'smtp_connection',
		fields: {
			transaction_id: `Transaction ID used by the server for this transaction (this ID is logged, mentioned in the DATA reply and part of the "Received:" header). It is based on the connection_id with a ":&lt;seq&gt;" sequence number suffix.`,
			session: `Session ID for this transaction (same as \`transaction_id\`).`,
			mail_from: `Sender address.`,
			mail_param_auth: `The value of the AUTH parameter for the MAIL command.`,
			mail_param_body: `The value of the BODY parameter for the MAIL command.`,
			mail_param_envid: `The value of the ENVID parameter for the MAIL command.`,
			mail_param_ret: `The value of the RET parameter for the MAIL command.`,
			mail_param_size: `The value of the SIZE parameter for the MAIL command.`,
			data_size: `The number data of bytes received from the client. This field is only present when the transaction finished receiving the DATA command.`,
		},
	},

	smtp_recipient: {
		inherit: 'smtp_transaction',
		fields: {
			rcpt_to: `Recipient address.`,
			rcpt_param_notify: `The value of the NOTIFY parameter for the RCPT command.`,
			rcpt_param_orcpt: `The address value of the ORCPT parameter for the RCPT command.`,
			rcpt_param_orcpt_type: `The address type (typically "rfc822") of the ORCPT parameter for the RCPT command.`,
			session: `Session ID for this transaction and recipient. It is based on the \`transaction_id\` with a ":&lt;seq&gt;" recipient sequence number suffix. Only available for LMTP currently.`,
		},
	},

	smtp_submit: {
		// TODO: Inherits from provided parent event
		fields: {
			mail_from: `The envelope sender for the outgoing message.`,
			recipients: `The number of recipients for the outgoing message.`,
			data_size: `The size of the outgoing message.`,
		},
	},

	sieve: {
		// TODO: Inherits from environment (LDA, LMTP or IMAP)
		fields: {
			user: `Username of the user.`,
		},
	},

	sieve_execute: {
		inherit: 'sieve',
		fields: {
			message_id: `The message-id of the message being filtered.`,
			mail_from: `Envelope sender address if available.`,
			rcpt_to: `Envelope recipient address if available.`,
		},
	},

	sieve_runtime: {
		inherit: 'sieve_execute',
		fields: {
			script_name: `The name of the Sieve script as it is visible to the user.`,
			script_location: `The full location string of the Sieve script.`,
			binary_path: `The path of the Sieve binary being executed (if it is not only in memory).`,
			error: `If present, this field indicates that the script execution has failed. The error message itself is very simple.`,
		},
	},

	sieve_storage: {
		inherit: 'sieve',
		fields: {
			storage_driver: `The driver name of the Sieve storage (\`file\`, \`ldap\`, or \`dict\`).`,
			script_location: `The location string for the Sieve script.`,
			error: `Error message for when storage operation has failed.`,
		},
	},

	managesieve: {
		// TODO: Inherits from client event
		fields: {
			cmd_name: `Name of the ManageSieve command.`,
			cmd_args: `Arguments for the ManageSieve command.`,
			error: `Error message for when the command failed.`,
		},
	},

	dict_common: {
		fields: {
			driver: `Name of the dictionary driver, e.g. \`sql\` or \`proxy\`.`,
			error: `Error, if one occurred.`
		},
	},

	dict_init: {
		inherit: 'dict_common',
		fields: {
			dict_name: `Name of the dict as set in configurations.`,
		},
	},

	dict_lookup: {
		inherit: 'dict_common',
		fields: {
			user: `Username, if it's not empty.`,
			key: `Key name, starts with \`priv/\` or \`shared/\`.`,
			key_not_found: `Set to \`yes\` if key not found.`,
		},
	},

	dict_iteration: {
		inherit: 'dict_lookup',
		fields: {
			rows: `Number of rows returned.`,
		},
	},

	dict_transaction: {
		inherit: 'dict_common',
		fields: {
			user: `Username, if it's not empty.`,
			rollback: `Set to \`yes\` when transaction was rolled back.`,
			write_uncertain: `Set to \`yes\` if write was not confirmed.`,
		},
	},

	pre_login_client: {
		fields: {
			local_ip: `Local IP address.`,
			local_port: `Local port.`,
			remote_ip: `Remote IP address.`,
			remote_port: `Remote port.`,
			user: `Full username.`,
			service: `Name of service e.g. \`submission\`, \`imap\`.`,
		},
	},

	login_proxy: {
		inherit: 'pre_login_client',
		fields: {
			dest_host: `Host name of the proxy destination (if proxying is configured with IP address, will have the same value as \`dest_ip\`).`,
			dest_ip: `Proxy destination IP.`,
			dest_port: `Proxy destination port.`,
			source_ip: `Source IP where proxy connection originated from.`,
			master_user: `If proxying is done with a master user authentication, contains the full username of master user.`,
		},
	},

	login_proxy_session: {
		inherit: 'login_proxy',
		fields: {
			source_port: `Source port where proxy connection originated from.`,
			reconnect_attempts: `Number of times connection failed and reconnection was attempted.`,
		},
	},

}
